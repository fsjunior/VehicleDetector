#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/features2d/features2d.hpp>
#include <opencv2/flann/miniflann.hpp>
//#include <cv.h>
#include <iostream>


namespace enc = sensor_msgs::image_encodings;


static const char WINDOW[] = "Vehicle Detector";
static const char REFERENCE_CAR[] = "images/carro.png";

class VehicleDetector {
    ros::NodeHandle nh_;
    image_transport::ImageTransport it_;
    image_transport::Subscriber image_sub_;
    cv::Mat referenceCar;

    
    std::vector<cv::KeyPoint> refCarKeypoints;
    cv::Mat refCarDescriptors;

    cv::Ptr<cv::SurfFeatureDetector> detector;
    cv::Ptr<cv::SurfDescriptorExtractor> extractor;
    //cv::SURF surf(500, 4, 2, false, true);

public:

    VehicleDetector()
    : it_(nh_)
    {
        image_sub_ = it_.subscribe("/stereo/left/image_rect_mono", 10, &VehicleDetector::imageCb, this);

        detector = new cv::SurfFeatureDetector(400., 3, 4, true);
        extractor = new cv::SurfDescriptorExtractor(3, 4, false, true);

        if (detector.empty() || extractor.empty()) {
            ROS_ERROR("Error trying to initialize SURF Descipror.");
            ros::shutdown();
        }

        if (!loadReferenceCar()) {
            ROS_ERROR("Error opening reference car in: %s.", REFERENCE_CAR);
            ros::shutdown();
        }

        cv::namedWindow(WINDOW);
    }

    ~VehicleDetector()
    {
        
        cv::destroyWindow(WINDOW);

        //surf.delete_obj();
    }


    void findPairs(cv::Mat& sceneDescriptors, std::vector<cv::DMatch>& pairs)
    {

        cv::FlannBasedMatcher matcher;
        std::vector< cv::DMatch > matches;
        float min_dist;
        
        matcher.match(refCarDescriptors, sceneDescriptors, matches);
        
        min_dist = matches.begin()->distance;

        for(std::vector<cv::DMatch>::iterator i = matches.begin(); i != matches.end(); i++)
            if(i->distance < min_dist)
                min_dist = i->distance;


        for(std::vector<cv::DMatch>::iterator i = matches.begin(); i != matches.end(); i++)
            if(i->distance < min_dist*1.5)
                pairs.push_back(*i);
                

    }


    void imageCb(const sensor_msgs::ImageConstPtr& msg)
    {
        cv_bridge::CvImagePtr cv_ptr;
        std::vector<cv::KeyPoint> sceneKeypoints;
        cv::Mat sceneDescriptors;
        std::vector<cv::DMatch> pairs;

        try {
            cv_ptr = cv_bridge::toCvCopy(msg);
        } catch (cv_bridge::Exception& e) {
            ROS_ERROR("cv_bridge exception: %s", e.what());
            return;
        }

        detector->detect(cv_ptr->image, sceneKeypoints);
        extractor->compute(cv_ptr->image, sceneKeypoints, sceneDescriptors);

        
        findPairs(sceneDescriptors, pairs);

        cv::Mat img_matches;

        cv::drawMatches(referenceCar, refCarKeypoints, cv_ptr->image, sceneKeypoints, pairs, img_matches, cv::Scalar::all(-1), cv::Scalar::all(-1),
               std::vector<char>(), cv::DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);

        imshow(WINDOW, img_matches );

        //for (std::vector<cv::KeyPoint>::iterator k = sceneKeypoints.begin(); k != sceneKeypoints.end(); k++)
        //    cv::circle(cv_ptr->image, k->pt, k->size * 1.2 / 9. * 2, cv::Scalar(255));

        //cv::imshow(WINDOW, cv_ptr->image);
        cv::waitKey(3);

    }

    bool loadReferenceCar()
    {
        referenceCar = cv::imread(REFERENCE_CAR, CV_LOAD_IMAGE_GRAYSCALE);
        if (referenceCar.data) {
            detector->detect(referenceCar, refCarKeypoints);
            extractor->compute(referenceCar, refCarKeypoints, refCarDescriptors);
            
            //(*surf)(referenceCar, mask, refCarKeypoints, refCarDescriptors); //Calcula keypoints e descriptors
            ROS_INFO("Keypoints in object: %d", refCarKeypoints.size());
            return true;
        }
        return false;
    }





};

int main(int argc, char** argv)
{
    ros::init(argc, argv, "vehicle_detector");

    VehicleDetector vd;
    ros::spin();
    return 0;
}
